[{"/Users/kuersch/workspace/js/useAudioPlayer/src/HowlInstanceManager.ts":"1","/Users/kuersch/workspace/js/useAudioPlayer/src/audioPlayerState.ts":"2","/Users/kuersch/workspace/js/useAudioPlayer/src/index.ts":"3","/Users/kuersch/workspace/js/useAudioPlayer/src/types.ts":"4","/Users/kuersch/workspace/js/useAudioPlayer/src/useAudioPlayer.ts":"5","/Users/kuersch/workspace/js/useAudioPlayer/src/useGlobalAudioPlayer.ts":"6","/Users/kuersch/workspace/js/useAudioPlayer/src/useHowlEventSync.ts":"7"},{"size":2116,"mtime":1683855434079,"results":"8","hashOfConfig":"9"},{"size":3835,"mtime":1683231518706,"results":"10","hashOfConfig":"9"},{"size":96,"mtime":1682652545045,"results":"11","hashOfConfig":"9"},{"size":1126,"mtime":1683231518708,"results":"12","hashOfConfig":"9"},{"size":3912,"mtime":1683231941492,"results":"13","hashOfConfig":"9"},{"size":4121,"mtime":1683231518750,"results":"14","hashOfConfig":"9"},{"size":3425,"mtime":1683855678389,"results":"15","hashOfConfig":"9"},{"filePath":"16","messages":"17","suppressedMessages":"18","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"p9zlqo",{"filePath":"19","messages":"20","suppressedMessages":"21","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"22"},{"filePath":"23","messages":"24","suppressedMessages":"25","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"26","messages":"27","suppressedMessages":"28","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"29","messages":"30","suppressedMessages":"31","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"32"},{"filePath":"33","messages":"34","suppressedMessages":"35","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"36"},{"filePath":"37","messages":"38","suppressedMessages":"39","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"/Users/kuersch/workspace/js/useAudioPlayer/src/HowlInstanceManager.ts",[],[],"/Users/kuersch/workspace/js/useAudioPlayer/src/audioPlayerState.ts",["40"],[],"import { Howl } from \"howler\"\n\nexport const ActionTypes = {\n    START_LOAD: \"START_LOAD\",\n    ON_LOAD: \"ON_LOAD\",\n    ON_ERROR: \"ON_ERROR\",\n    ON_PLAY: \"ON_PLAY\",\n    ON_PAUSE: \"ON_PAUSE\",\n    ON_STOP: \"ON_STOP\",\n    ON_END: \"ON_END\",\n    ON_RATE: \"ON_RATE\",\n    ON_MUTE: \"ON_MUTE\",\n    ON_VOLUME: \"ON_VOLUME\",\n    ON_LOOP: \"ON_LOOP\"\n}\n\ninterface BaseAction {\n    type: keyof typeof ActionTypes\n}\n\nexport interface AudioEvent {\n    type: Omit<keyof typeof ActionTypes, \"ON_ERROR\">\n    howl: Howl\n    toggleValue?: boolean\n}\n\nexport interface ErrorEvent {\n    type: \"ON_ERROR\"\n    message: string\n}\n\nexport type Action = BaseAction | AudioEvent | ErrorEvent\n\nexport interface AudioPlayerState {\n    src: string | null\n    looping: boolean\n    isReady: boolean\n    paused: boolean\n    stopped: boolean\n    playing: boolean\n    duration: number\n    muted: boolean\n    rate: number\n    volume: number\n    error: string | null\n}\n\nexport function initStateFromHowl(howl?: Howl): AudioPlayerState {\n    if (howl === undefined) {\n        return {\n            src: null,\n            isReady: false,\n            looping: false,\n            duration: 0,\n            rate: 1,\n            volume: 1,\n            muted: false,\n            playing: false,\n            paused: false,\n            stopped: false,\n            error: null\n        }\n    }\n\n    const position = howl.seek()\n    const playing = howl.playing()\n\n    return {\n        isReady: howl.state() === \"loaded\",\n        // @ts-ignore _src exists\n        src: howl._src,\n        looping: howl.loop(),\n        duration: howl.duration(),\n        rate: howl.rate(),\n        volume: howl.volume(),\n        muted: false,\n        playing,\n        paused: !playing,\n        stopped: !playing && position === 0,\n        error: null\n    }\n}\n\nexport function reducer(state: AudioPlayerState, action: Action) {\n    switch (action.type) {\n        case ActionTypes.START_LOAD:\n            return state\n        case ActionTypes.ON_LOAD:\n            return initStateFromHowl((action as AudioEvent).howl)\n        case ActionTypes.ON_ERROR:\n            return {\n                // this essentially resets state when called with undefined\n                ...initStateFromHowl(),\n                error: (action as ErrorEvent).message\n            }\n        case ActionTypes.ON_PLAY:\n            return {\n                ...state,\n                playing: true,\n                paused: false,\n                stopped: false\n            }\n        case ActionTypes.ON_PAUSE:\n            return {\n                ...state,\n                playing: false,\n                paused: true\n            }\n        case ActionTypes.ON_STOP: {\n            return {\n                ...state,\n                playing: false,\n                paused: false,\n                stopped: true\n            }\n        }\n        case ActionTypes.ON_END: {\n            return {\n                ...state,\n                playing: state.looping,\n                stopped: !state.looping\n            }\n        }\n        case ActionTypes.ON_MUTE: {\n            return {\n                ...state,\n                muted: (action as AudioEvent).howl.mute() ?? false\n            }\n        }\n        case ActionTypes.ON_RATE: {\n            return {\n                ...state,\n                rate: (action as AudioEvent).howl?.rate() ?? 1.0\n            }\n        }\n        case ActionTypes.ON_VOLUME: {\n            return {\n                ...state,\n                volume: (action as AudioEvent).howl?.volume() ?? 1.0\n            }\n        }\n        case ActionTypes.ON_LOOP: {\n            const { toggleValue = false, howl } = action as AudioEvent\n            howl.loop(toggleValue)\n            return {\n                ...state,\n                looping: toggleValue\n            }\n        }\n        default:\n            return state\n    }\n}\n","/Users/kuersch/workspace/js/useAudioPlayer/src/index.ts",[],[],"/Users/kuersch/workspace/js/useAudioPlayer/src/types.ts",[],[],"/Users/kuersch/workspace/js/useAudioPlayer/src/useAudioPlayer.ts",["41","42","43"],[],"import { useCallback, useEffect, useReducer, useRef } from \"react\"\nimport {\n    initStateFromHowl,\n    reducer as audioStateReducer\n} from \"./audioPlayerState\"\nimport { useHowlEventSync } from \"./useHowlEventSync\"\nimport { HowlInstanceManager } from \"./HowlInstanceManager\"\nimport { AudioPlayer, LoadArguments } from \"./types\"\n\nexport const useAudioPlayer = (): AudioPlayer => {\n    const howlManager = useRef(new HowlInstanceManager())\n    const [state, dispatch] = useHowlEventSync(\n        howlManager.current,\n        useReducer(\n            audioStateReducer,\n            howlManager.current.getHowl(),\n            initStateFromHowl\n        )\n    )\n\n    useEffect(() => {\n        // stop/delete the sound object when the hook unmounts\n        return () => {\n            howlManager.current.destroyHowl()\n        }\n    }, [])\n\n    const load = useCallback((...[src, options = {}]: LoadArguments) => {\n        const howl = howlManager.current.createHowl({\n            src,\n            ...options\n        })\n\n        dispatch({ type: \"START_LOAD\", howl })\n    }, [])\n\n    const seek = useCallback((seconds: number) => {\n        const howl = howlManager.current.getHowl()\n        if (howl === undefined) {\n            return\n        }\n\n        howl.seek(seconds)\n    }, [])\n\n    const getPosition = useCallback(() => {\n        const howl = howlManager.current.getHowl()\n        if (howl === undefined) {\n            return 0\n        }\n\n        return howl.seek() ?? 0\n    }, [])\n\n    const play = useCallback(() => {\n        const howl = howlManager.current.getHowl()\n        if (howl === undefined) {\n            return\n        }\n\n        howl.play()\n    }, [])\n\n    const pause = useCallback(() => {\n        const howl = howlManager.current.getHowl()\n        if (howl === undefined) {\n            return\n        }\n\n        howl.pause()\n    }, [])\n\n    const togglePlayPause = useCallback(() => {\n        const howl = howlManager.current.getHowl()\n        if (howl === undefined) {\n            return\n        }\n\n        if (state.playing) {\n            howl.pause()\n        } else {\n            howl.play()\n        }\n    }, [state])\n\n    const stop = useCallback(() => {\n        const howl = howlManager.current.getHowl()\n        if (howl === undefined) {\n            return\n        }\n\n        howl.stop()\n    }, [])\n\n    const fade = useCallback((from: number, to: number, duration: number) => {\n        const howl = howlManager.current.getHowl()\n        if (howl === undefined) {\n            return\n        }\n\n        howl.fade(from, to, duration)\n    }, [])\n\n    const setRate = useCallback((speed: number) => {\n        const howl = howlManager.current.getHowl()\n        if (howl === undefined) {\n            return\n        }\n\n        howl.rate(speed)\n    }, [])\n\n    const setVolume = useCallback((vol: number) => {\n        const howl = howlManager.current.getHowl()\n        if (howl === undefined) {\n            return\n        }\n\n        howl.volume(vol)\n    }, [])\n\n    const mute = useCallback((muteOnOff: boolean) => {\n        const howl = howlManager.current.getHowl()\n        if (howl === undefined) {\n            return\n        }\n\n        howl.mute(muteOnOff)\n    }, [])\n\n    const loop = useCallback((loopOnOff: boolean) => {\n        const howl = howlManager.current.getHowl()\n        if (howl === undefined) {\n            return\n        }\n\n        // this differs from the implementation in useGlobalAudioPlayer which needs to broadcast the action to itself and all other instances of the hook\n        // maybe these two behaviors could be abstracted with one interface in the future\n        dispatch({ type: \"ON_LOOP\", howl, toggleValue: loopOnOff })\n    }, [])\n\n    return {\n        ...state,\n        load,\n        seek,\n        getPosition,\n        play,\n        pause,\n        togglePlayPause,\n        stop,\n        mute,\n        fade,\n        setRate,\n        setVolume,\n        loop\n    }\n}\n","/Users/kuersch/workspace/js/useAudioPlayer/src/useGlobalAudioPlayer.ts",["44","45"],[],"import { useCallback, useEffect, useReducer, useRef } from \"react\"\nimport {\n    Action,\n    initStateFromHowl,\n    reducer as audioStateReducer\n} from \"./audioPlayerState\"\nimport { useHowlEventSync } from \"./useHowlEventSync\"\nimport { HowlInstanceManagerSingleton } from \"./HowlInstanceManager\"\nimport { AudioPlayer, LoadArguments } from \"./types\"\n\nexport const useGlobalAudioPlayer = (): AudioPlayer => {\n    const howlManager = useRef(HowlInstanceManagerSingleton.getInstance())\n\n    const [state, dispatch] = useHowlEventSync(\n        howlManager.current,\n        useReducer(\n            audioStateReducer,\n            howlManager.current.getHowl(),\n            initStateFromHowl\n        )\n    )\n\n    useEffect(() => {\n        const howlOnMount = howlManager.current.getHowl()\n        if (howlOnMount !== undefined) {\n            dispatch({ type: \"START_LOAD\", howl: howlOnMount })\n            if (howlOnMount.state() === \"loaded\") {\n                dispatch({ type: \"ON_LOAD\", howl: howlOnMount })\n            }\n        }\n\n        function sync(action: Action) {\n            dispatch(action)\n        }\n\n        const subscriptionId = howlManager.current.subscribe(sync)\n\n        return () => {\n            howlManager.current.unsubscribe(subscriptionId)\n        }\n    }, [])\n\n    const load = useCallback((...[src, options = {}]: LoadArguments) => {\n        howlManager.current.createHowl({\n            src,\n            ...options\n        })\n    }, [])\n\n    const seek = useCallback((seconds: number) => {\n        const howl = howlManager.current.getHowl()\n        if (howl === undefined) {\n            return\n        }\n\n        howl.seek(seconds)\n    }, [])\n\n    const getPosition = useCallback(() => {\n        const howl = howlManager.current.getHowl()\n        if (howl === undefined) {\n            return 0\n        }\n\n        return howl.seek() ?? 0\n    }, [])\n\n    const play = useCallback(() => {\n        const howl = howlManager.current.getHowl()\n        if (howl === undefined) {\n            return\n        }\n\n        howl.play()\n    }, [])\n\n    const pause = useCallback(() => {\n        const howl = howlManager.current.getHowl()\n        if (howl === undefined) {\n            return\n        }\n\n        howl.pause()\n    }, [])\n\n    const togglePlayPause = useCallback(() => {\n        const howl = howlManager.current.getHowl()\n        if (howl === undefined) {\n            return\n        }\n\n        if (state.playing) {\n            howl.pause()\n        } else {\n            howl.play()\n        }\n    }, [state])\n\n    const stop = useCallback(() => {\n        const howl = howlManager.current.getHowl()\n        if (howl === undefined) {\n            return\n        }\n\n        howl.stop()\n    }, [])\n\n    const fade = useCallback((from: number, to: number, duration: number) => {\n        const howl = howlManager.current.getHowl()\n        if (howl === undefined) {\n            return\n        }\n\n        howl.fade(from, to, duration)\n    }, [])\n\n    const setRate = useCallback((speed: number) => {\n        const howl = howlManager.current.getHowl()\n        if (howl === undefined) {\n            return\n        }\n\n        howl.rate(speed)\n    }, [])\n\n    const setVolume = useCallback((vol: number) => {\n        const howl = howlManager.current.getHowl()\n        if (howl === undefined) {\n            return\n        }\n\n        howl.volume(vol)\n    }, [])\n\n    const mute = useCallback((muteOnOff: boolean) => {\n        const howl = howlManager.current.getHowl()\n        if (howl === undefined) {\n            return\n        }\n\n        howl.mute(muteOnOff)\n    }, [])\n\n    const loop = useCallback((loopOnOff: boolean) => {\n        const howl = howlManager.current.getHowl()\n        if (howl === undefined) {\n            return\n        }\n\n        howlManager.current.broadcast({\n            type: \"ON_LOOP\",\n            howl,\n            toggleValue: loopOnOff\n        })\n    }, [])\n\n    return {\n        ...state,\n        load,\n        seek,\n        getPosition,\n        play,\n        pause,\n        togglePlayPause,\n        stop,\n        mute,\n        fade,\n        setRate,\n        setVolume,\n        loop\n    }\n}\n","/Users/kuersch/workspace/js/useAudioPlayer/src/useHowlEventSync.ts",["46"],[],{"ruleId":"47","severity":1,"message":"48","line":70,"column":9,"nodeType":"49","messageId":"50","endLine":70,"endColumn":34},{"ruleId":"51","severity":1,"message":"52","line":24,"column":25,"nodeType":"53","endLine":24,"endColumn":32},{"ruleId":"51","severity":1,"message":"54","line":35,"column":8,"nodeType":"55","endLine":35,"endColumn":10,"suggestions":"56"},{"ruleId":"51","severity":1,"message":"54","line":140,"column":8,"nodeType":"55","endLine":140,"endColumn":10,"suggestions":"57"},{"ruleId":"51","severity":1,"message":"52","line":39,"column":25,"nodeType":"53","endLine":39,"endColumn":32},{"ruleId":"51","severity":1,"message":"58","line":41,"column":8,"nodeType":"55","endLine":41,"endColumn":10,"suggestions":"59"},{"ruleId":"51","severity":1,"message":"60","line":83,"column":8,"nodeType":"55","endLine":83,"endColumn":10,"suggestions":"61"},"@typescript-eslint/ban-ts-comment","Do not use \"@ts-ignore\" because it alters compilation errors.","Line","tsDirectiveComment","react-hooks/exhaustive-deps","The ref value 'howlManager.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'howlManager.current' to a variable inside the effect, and use that variable in the cleanup function.","Identifier","React Hook useCallback has a missing dependency: 'dispatch'. Either include it or remove the dependency array.","ArrayExpression",["62"],["63"],"React Hook useEffect has a missing dependency: 'dispatch'. Either include it or remove the dependency array.",["64"],"React Hook useEffect has missing dependencies: 'howlManager', 'onEnd', 'onError', 'onMute', 'onPause', 'onPlay', 'onRate', 'onStop', and 'onVolume'. Either include them or remove the dependency array.",["65"],{"desc":"66","fix":"67"},{"desc":"66","fix":"68"},{"desc":"66","fix":"69"},{"desc":"70","fix":"71"},"Update the dependencies array to be: [dispatch]",{"range":"72","text":"73"},{"range":"74","text":"73"},{"range":"75","text":"73"},"Update the dependencies array to be: [howlManager, onEnd, onError, onMute, onPause, onPlay, onRate, onStop, onVolume]",{"range":"76","text":"77"},[1065,1067],"[dispatch]",[3674,3676],[1275,1277],[2521,2523],"[howlManager, onEnd, onError, onMute, onPause, onPlay, onRate, onStop, onVolume]"]